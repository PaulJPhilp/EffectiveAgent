/**
 * @file Implements the TagService using the Effect.Service pattern.
 */

import type { EntityId } from "@/types.js";
import type { RepositoryServiceApi } from "@core/repository/api.js";
import {
  DuplicateTagNameError,
  LinkAlreadyExistsError,
  LinkNotFoundError,
  TagDbError,
  TagNotFoundError,
} from "./errors.js";
import type {
  EntityTagLinkEntity,
  EntityTagLinkEntityData,
  TagEntity,
} from "./schema.js";
import * as Effect from "effect/Effect";
import { Layer, Option } from "effect";
import type { TagServiceApi } from "./api.js";
import type { TaggedEntityRef } from "./types.js";
import { EntityNotFoundError, RepositoryError } from "@core/repository/errors.js";
import RepositoryService from "../repository/service.js";
import { FindOptions } from "../repository/types.js";

/**
 * Helper function to normalize tag names for consistent storage and lookup.
 */
const normalizeTagName = (name: string): string => name.trim().toLowerCase();

/**
 * Implementation of the TagService using the Effect.Service pattern
 */
export class TagService extends Effect.Service<TagServiceApi>()(
  "TagService",
  {
    effect: Effect.gen(function* () {
      // Get repository instances
      const tagRepo = yield* RepositoryService<TagEntity>().Tag;
      const linkRepo = yield* RepositoryService<EntityTagLinkEntity>().Tag;
    })
  }
)
  createTag = (name: string): Effect.Effect<TagEntity, TagDbError | DuplicateTagNameError> => {
    const normalizedName = normalizeTagName(name);
    
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      
      // Check if tag with same name already exists
      const existingTag = yield* tagRepo.findOne({
        filter: { name: normalizedName }
      });

      if (Option.isSome(existingTag)) {
        return yield* Effect.fail(
          new DuplicateTagNameError({
            tagName: name,
            message: `Tag with name '${name}' already exists`,
          })
        );
      }

      // Create new tag
      try {
        const newTag = yield* tagRepo.create({
          name: normalizedName,
        });

        return newTag;
      } catch (error) {
        return yield* Effect.fail(
          new TagDbError({
            message: `Failed to create tag '${name}'`,
            cause: error,
          })
        );
      }
    }).pipe(
      Effect.catchTag("RepositoryError", (error) => 
        Effect.fail(new TagDbError({
          message: `Repository error: ${error.message}`,
          cause: error
        }))
      )
    );
  };

    return {
      createTag: (name: string): Effect.Effect<TagEntity, TagDbError | DuplicateTagNameError> => {
        const { tagRepository } = depsRef;
        const normalizedName = normalizeTagName(name);

        return Effect.gen(function* () {
          // Check if tag with same name already exists
          const existingTag = yield* tagRepository.findOne({
            where: { name: normalizedName },
          });

          if (Option.isSome(existingTag)) {
            return yield* Effect.fail(
              new DuplicateTagNameError({
                tagName: name,
                message: `Tag with name '${name}' already exists`,
              })
            );
          }

          // Create new tag
          try {
            const newTag = yield* tagRepository.create({
              name: normalizedName,
            });

            return newTag;
          } catch (error) {
            return yield* Effect.fail(
              new TagDbError({
                message: `Failed to create tag '${name}'`,
                cause: error,
              })
            );
          }
        });
      },

      /**
       * Gets a tag by its ID.
       * @param id The ID of the tag to get.
       * @returns An Effect resolving to the tag.
       */
      /**
   * Gets a tag by its ID.
   * @param id The ID of the tag to get.
   * @returns An Effect resolving to the tag.
   */
  getTagById = (id: EntityId): Effect.Effect<Option.Option<TagEntity>, TagDbError> => {
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      
      try {
        const tag = yield* tagRepo.findById(id);
        return tag;
      } catch (error) {
        return yield* Effect.fail(
          new TagDbError({
            message: `Failed to get tag: ${error instanceof Error ? error.message : String(error)}`,
            cause: error,
          })
        );
      }
    }).pipe(
      Effect.catchTag("RepositoryError", (error) => 
        Effect.fail(new TagDbError({
          message: `Repository error: ${error.message}`,
          cause: error
        }))
      )
    );
  };

      /**
       * Gets a tag by its name.
       * @param name The name of the tag to get.
       * @returns An Effect resolving to the tag.
       */
  /**
   * Gets a tag by its name.
   * @param name The name of the tag to get.
   * @returns An Effect resolving to the tag.
   */
  getTagByName = (name: string): Effect.Effect<Option.Option<TagEntity>, TagDbError> => {
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      
      try {
        const normalizedName = normalizeTagName(name);

        const tag = yield* tagRepo.findOne({
          filter: { name: normalizedName }
        });

        return tag;
      } catch (error) {
        return yield* Effect.fail(
          new TagDbError({
            operation: "getTagByName",
            message: `Failed to get tag by name: ${error instanceof Error ? error.message : String(error)}`,
            cause: error,
          })
        );
      }
    }).pipe(
      Effect.catchTag("RepositoryError", (error) => 
        Effect.fail(new TagDbError({
          message: `Repository error: ${error.message}`,
          cause: error
        }))
      )
    );
  };

      /**
       * Finds tags matching the given query.
       * @param prefix Optional prefix to filter tags by.
       * @returns An Effect resolving to an array of matching tags.
       */
  /**
   * Finds tags matching the given query.
   * @param prefix Optional prefix to filter tags by.
   * @returns An Effect resolving to an array of matching tags.
   */
  findTags = (prefix?: string): Effect.Effect<ReadonlyArray<TagEntity>, TagDbError> => {
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      
      try {
        const normalizedPrefix = prefix ? normalizeTagName(prefix) : undefined;

        const tags = yield* tagRepo.findMany({
          filter: normalizedPrefix ? { name: { startsWith: normalizedPrefix } } : undefined
        });

        return tags as ReadonlyArray<TagEntity>;
      } catch (error) {
        return yield* Effect.fail(
          new TagDbError({
            operation: "findTags",
            message: `Failed to find tags: ${error instanceof Error ? error.message : String(error)}`,
            cause: error,
          })
        );
      }
    }).pipe(
      Effect.catchTag("RepositoryError", (error) => 
        Effect.fail(new TagDbError({
          message: `Repository error: ${error.message}`,
          cause: error
        }))
      )
    );
  };

      /**
       * Tags an entity with the given tag.
       * @param tagId The ID of the tag to use.
       * @param entityId The ID of the entity to tag.
       * @param entityType The type of the entity to tag.
       * @returns An Effect resolving to void.
       */
  /**
   * Tags an entity with the given tag.
   * @param tagId The ID of the tag to use.
   * @param entityId The ID of the entity to tag.
   * @param entityType The type of the entity to tag.
   * @returns An Effect resolving to void.
   */
  tagEntity = (
    tagId: EntityId, 
    entityId: EntityId, 
    entityType: string
  ): Effect.Effect<void, TagDbError | TagNotFoundError | LinkAlreadyExistsError> => {
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      const linkRepo = yield* TagService.linkRepo.Tag;
      
      // Verify tag exists
      const tagOption = yield* tagRepo.findById(tagId);

      if (Option.isNone(tagOption)) {
        return yield* Effect.fail(
          new TagNotFoundError({
            identifier: tagId,
            message: `Tag with ID '${tagId}' not found`,
          })
        );
      }

      // Check if link already exists
      const existingLink = yield* linkRepo.findOne({
        filter: { tagId, entityId, entityType }
      });

      if (Option.isSome(existingLink)) {
        return yield* Effect.fail(
          new LinkAlreadyExistsError({
            tagId,
            entityId,
            entityType,
            message: `Entity ${entityType}:${entityId} is already tagged with tag ${tagId}`,
          })
        );
      }

      // Create new link
      try {
        const newLink = yield* linkRepo.create({
          tagId,
          entityId,
          entityType,
        });

        return newLink;
      } catch (error) {
        return yield* Effect.fail(
          new TagDbError({
            operation: "tagEntity",
            message: `Failed to tag entity: ${error instanceof Error ? error.message : String(error)}`,
            cause: error,
          })
        );
      }
    }).pipe(
      Effect.catchTag("RepositoryError", (error) => 
        Effect.fail(new TagDbError({
          message: `Repository error: ${error.message}`,
          cause: error
        }))
      )
    );
  };

      /**
       * Removes a tag from an entity.
       * @param tagId The ID of the tag to remove.
       * @param entityId The ID of the entity to untag.
       * @param entityType The type of the entity to untag.
       * @returns An Effect resolving to void.
       */
  /**
   * Removes a tag from an entity.
   * @param tagId The ID of the tag to remove.
   * @param entityId The ID of the entity to untag.
   * @param entityType The type of the entity to untag.
   * @returns An Effect resolving to void.
   */
  untagEntity = (
    tagId: EntityId, 
    entityId: EntityId, 
    entityType: string
  ): Effect.Effect<void, TagDbError | LinkNotFoundError> => {
    return Effect.gen(function* () {
      const linkRepo = yield* TagService.linkRepo.Tag;
      
      // Find the specific link to delete
      const linkOption = yield* linkRepo.findOne({
        filter: { tagId, entityId, entityType }
      }).pipe(
        Effect.mapError(
          (cause) =>
            new TagDbError({
              operation: "untagEntity (find link)",
              message: "DB error finding link to delete",
              cause,
            }),
        ),
      );

      if (Option.isNone(linkOption)) {
        // If link doesn't exist, fail
        return yield* Effect.fail(
          new LinkNotFoundError({
            tagId,
            entityId,
            entityType,
            message: `Link between tag ${tagId} and entity ${entityType}:${entityId} not found`,
          })
        );
      }

      // If link exists, delete it by its ID
      const linkToDelete = linkOption.value;
      yield* linkRepo.delete(linkToDelete.id).pipe(
        Effect.mapError((repoError) => {
          // Check if repo error was EntityNotFoundError (shouldn't happen if findOne succeeded)
          if (repoError instanceof EntityNotFoundError) {
            return new LinkNotFoundError({
              tagId,
              entityId,
              entityType,
              message: "Link disappeared before delete"
            });
          }
          // Otherwise wrap as generic DB error
          return new TagDbError({
            operation: "untagEntity (delete link)",
            message: `DB error deleting link ID ${linkToDelete.id}`,
            cause: repoError,
          });
        }),
      );
    });
  };

      /**
       * Gets all tags for an entity.
       * @param entityId The ID of the entity to get tags for.
       * @param entityType The type of the entity to get tags for.
       * @returns An Effect resolving to an array of tags.
       */
  /**
   * Gets all tags for an entity.
   * @param entityId The ID of the entity to get tags for.
   * @param entityType The type of the entity to get tags for.
   * @returns An Effect resolving to an array of tags.
   */
  getTagsForEntity = (
    entityId: EntityId,
    entityType: string
  ): Effect.Effect<ReadonlyArray<TagEntity>, TagDbError> => {
    return Effect.gen(function* () {
      const tagRepo = yield* TagService.tagRepo.Tag;
      const linkRepo = yield* TagService.linkRepo.Tag;
      
      // Find all links for the entity
      const links: ReadonlyArray<EntityTagLinkEntity> = yield* linkRepo.findMany({
        filter: { entityId, entityType }
      }).pipe(
        Effect.mapError(
          (cause) =>
            new TagDbError({
              operation: "getTagsForEntity (find links)",
              message: `DB error finding links for ${entityType}:${entityId}`,
              cause,
            }),
        ),
      );

      // If no links found, return empty array
      if (links.length === 0) {
        return [] as ReadonlyArray<TagEntity>;
      }

      // Extract tagIds and fetch corresponding tags
      const tagIds = links.map((link) => link.data.tagId);

      // Fetch all tags matching the found IDs
      return yield* tagRepo.findMany({
        filter: { id: { in: tagIds } },
      }).pipe(
        Effect.map(tags => tags as ReadonlyArray<TagEntity>),
        Effect.mapError(
          (cause) =>
            new TagDbError({
              operation: "getTagsForEntity (find tags)",
              message: `DB error finding tags for entity ${entityType}:${entityId}`,
              cause,
            }),
        ),
      );
    });
  };

      /**
       * Gets all entities for a tag.
       * @param tagId The ID of the tag to get entities for.
       * @returns An Effect resolving to an array of entity references.
       */
  /**
   * Gets all entities for a tag.
   * @param tagId The ID of the tag to get entities for.
   * @returns An Effect resolving to an array of entity references.
   */
  getEntitiesForTag = (
    tagId: EntityId
  ): Effect.Effect<ReadonlyArray<TaggedEntityRef>, TagDbError> => {
    return Effect.gen(function* () {
      const linkRepo = yield* TagService.linkRepo.Tag;
      
      // Find all links for the tag
      const links: ReadonlyArray<EntityTagLinkEntity> = yield* linkRepo.findMany({
        filter: { tagId }
      }).pipe(
        Effect.mapError(
          (cause) =>
            new TagDbError({
              operation: "getEntitiesForTag (find links)",
              message: `DB error finding links for tag ${tagId}`,
              cause,
            }),
        ),
      );

      // Map results to the desired { entityId, entityType } shape
      return links.map((link) => ({
        entityId: link.data.entityId,
        entityType: link.data.entityType,
      })) as ReadonlyArray<TaggedEntityRef>;
    });
  };
}

/**
 * Live layer for the TagService.
 */
export const TagServiceLive = Layer.succeed(TagService);

/**
 * Default export for the TagService.
 */
export default TagService;