/**
 * @file Integration test for the Summarization Agent with conditional routing
 * @module examples/summarization-agent
 */

import { EffectLangGraphRunner } from "@effective-agent/langgraph";
import { Effect } from "effect";
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { AgentRunInput } from "@/agent-runner.js";

// Mock the AI SDK functions
vi.mock("@effective-agent/ai-sdk", () => ({
    generateTextWithModel: vi.fn(),
    getLanguageModelByName: vi.fn()
}));

// Mock the fetch content tool
vi.mock("../../../services/ai/tools/implementations/fetch-content.js", () => ({
    fetchContentImpl: vi.fn()
}));

import { generateTextWithModel, getLanguageModelByName } from "@effective-agent/ai-sdk";
import { fetchContentImpl } from "../../../services/ai/tools/implementations/fetch-content.js";

describe("Summarization Agent Integration", () => {
    let runner: EffectLangGraphRunner;

    beforeEach(() => {
        vi.clearAllMocks();
        runner = new EffectLangGraphRunner();

        // Setup default mocks that return Effect values
        (getLanguageModelByName as any).mockReturnValue(Effect.succeed({}));
        (generateTextWithModel as any).mockReturnValue(Effect.succeed({
            data: { text: "This is a mock summary generated by the LLM." }
        }));
        (fetchContentImpl as any).mockReturnValue(Effect.succeed({
            content: "This is the fetched content from the URL.",
            url: "https://example.com"
        }));
    });

    describe("Plain Text Summarization", () => {
        it("should summarize plain text without using tools", async () => {
            const input: AgentRunInput = {
                prompt: "Summarize this: Effect-TS is a functional programming library for TypeScript that provides powerful abstractions for handling effects, errors, and async operations in a composable way.",
                modelId: "gpt-4o",
                context: { test: true }
            };

            const result = await Effect.runPromise(runner.run(input));

            // Verify the agent ran successfully
            expect(result).toBeDefined();
            expect(result.response).toBeDefined();
            expect(result.metadata).toBeDefined();

            // Verify no tool was called (plain text path)
            expect(fetchContentImpl).not.toHaveBeenCalled();

            // Verify LLM was called for summarization
            expect(generateTextWithModel).toHaveBeenCalledTimes(1);

            // Verify the response contains the mock summary
            expect(result.response).toContain("mock summary");
        });
    });

    describe("URL Content Summarization", () => {
        it("should fetch URL content and then summarize it", async () => {
            // Save original fetch and mock it (in case the mock doesn't work)
            const originalFetch = global.fetch;
            const mockFetch = vi.fn();
            global.fetch = mockFetch;
            mockFetch.mockResolvedValue({
                ok: true,
                headers: { get: () => 'text/html' },
                text: () => Promise.resolve('<html><body>This is the fetched content from the URL.</body></html>')
            });

            const input: AgentRunInput = {
                prompt: "Please summarize the content from https://example.com",
                modelId: "gpt-4o",
                context: { test: true }
            };

            const result = await Effect.runPromise(runner.run(input));

            // Verify the agent ran successfully
            expect(result).toBeDefined();
            expect(result.response).toBeDefined();
            expect(result.metadata).toBeDefined();

            // Verify the tool was called (this is the key assertion)
            expect(fetchContentImpl).toHaveBeenCalledWith({ url: "https://example.com" });

            // Verify LLM was called for summarization
            expect(generateTextWithModel).toHaveBeenCalledTimes(1);

            // Verify the response contains the mock summary
            expect(result.response).toContain("mock summary");

            // Restore global fetch
            global.fetch = originalFetch;
        });
    });
});