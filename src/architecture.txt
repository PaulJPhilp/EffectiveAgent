# Agent Framework Architecture Document

**Version:** 1.0
**Date:** 2024-07-26

## 1. Overview

This document outlines the architecture of the Effect-based agent framework. The framework's primary goal is to simplify the development of robust, maintainable, and scalable AI agents by providing a set of core services built on the Effect-TS ecosystem. It handles common concerns like configuration, logging, external tool usage, interaction with external platforms (MCPs), prompt management, model interaction, and data persistence, allowing agent authors to focus on the agent's specific logic and capabilities.

## 2. Core Principles

*   **Effect-TS Native:** Leverage Effect-TS for managing effects, dependencies, concurrency, error handling, and resource management, ensuring type safety and composability.
*   **Modularity & Composability:** Services are designed as distinct, replaceable modules managed via Effect's `Context` (`Tag`) and `Layer` system.
*   **Dependency Injection:** Services declare their dependencies, which are automatically provided by the Effect runtime via Layers.
*   **Separation of Concerns:** Each service has a clearly defined responsibility (e.g., configuration, logging, tool execution, MCP client access).
*   **Configuration Driven:** Agent and service behavior is controlled through external configuration, managed by a dedicated service.
*   **Extensibility:** The framework is designed to be extended with custom tools, MCP clients, models, prompts, and repository implementations.
*   **Observability:** Integrated logging provides insights into the agent's execution flow and potential issues.
*   **Developer Experience:** Abstract away boilerplate for common agent tasks, providing clear, typed APIs.

## 3. High-Level Architecture

The framework operates around a central **Agent Runtime** (which could be a specific implementation using concepts from libraries like LangGraph or a custom loop). This runtime orchestrates the agent's lifecycle and interactions.


**Flow:**

1.  **Initialization:** The application starts, loading configuration via `ConfigurationService`. Effect Layers are used to construct and provide all necessary services (`LoggingService`, `ToolService`, `MCPClientService`, etc.).
2.  **Agent Execution:** The Agent Runtime begins execution based on the user-provided Agent Definition.
3.  **Service Usage:** The Agent Definition logic interacts with framework services as needed:
    *   Fetches prompts via `PromptService`.
    *   Interacts with LLMs via `ModelProviderService`.
    *   Invokes tools via `ToolService`.
    *   Accesses external platforms via `MCPClientService`.
    *   Reads/writes persistent data via `RepositoryService`.
    *   All operations are logged via `LoggingService`.
4.  **External Interactions:** `ToolService` might execute local functions or call external APIs. `MCPClientService` facilitates authenticated calls to platforms like Gmail, HubSpot, etc. `ModelProviderService` communicates with LLM APIs.
5.  **Completion/Response:** The agent produces a result or continues its execution loop.

## 4. Key Components

*   **`ConfigurationService`:**
    *   **Responsibility:** Loads, validates, and provides access to application configuration (from environment variables, files, etc.).
    *   **Interface:** Provides methods like `getConfig(path)` or `getValidatedConfig(path, schema)`.
    *   **Dependencies:** None (typically).
    *   **Used By:** Almost all other services, Agent Runtime.
*   **`LoggingService`:**
    *   **Responsibility:** Provides structured, contextual logging capabilities.
    *   **Interface:** Provides methods like `getLogger(context)` which returns a `Logger` with methods (`info`, `warn`, `error`, `debug`). Supports annotations.
    *   **Dependencies:** None (typically).
    *   **Used By:** All other services, Agent Runtime.
*   **`ToolService`:**
    *   **Responsibility:** Manages the registration, discovery, and invocation of "Tools" (functions the agent can execute). Handles input/output validation (using Zod schemas defined with the tool).
    *   **Interface:** `registerTool`, `getTool`, `listTools`, `invokeTool`.
    *   **Dependencies:** `LoggingService`, `ConfigurationService` (passed via `ToolExecutionContext`).
    *   **Used By:** Agent Runtime/Logic.
*   **`MCPClientService`:**
    *   **Responsibility:** Manages the registration, configuration, initialization, and access to Multi-Channel Platform (MCP) clients (e.g., Gmail, GitHub, HubSpot). Abstracts authentication and API setup.
    *   **Interface:** `registerClient`, `getClient`, `listClients`.
    *   **Dependencies:** `LoggingService`, `ConfigurationService`.
    *   **Used By:** Agent Runtime/Logic, potentially by Tools.
*   **`PromptService`:**
    *   **Responsibility:** Manages loading, formatting, and providing access to prompt templates.
    *   **Interface:** `getPrompt(id)`, `formatPrompt(id, variables)`.
    *   **Dependencies:** `LoggingService`, potentially `ConfigurationService`.
    *   **Used By:** Agent Runtime/Logic.
*   **`ModelProviderService`:**
    *   **Responsibility:** Abstracts interactions with different Large Language Model (LLM) providers (e.g., OpenAI, Anthropic, local models). Handles API calls, configuration (API keys via `ConfigurationService`), and potentially basic retry/error handling. May integrate with libraries like Vercel AI SDK.
    *   **Interface:** `generateCompletion(prompt, options)`, `streamCompletion(prompt, options)`.
    *   **Dependencies:** `LoggingService`, `ConfigurationService`.
    *   **Used By:** Agent Runtime/Logic.
*   **`RepositoryService`:**
    *   **Responsibility:** Provides an abstraction layer for data persistence (e.g., agent state, conversation history, user data). Allows different storage backends (in-memory, database, file system).
    *   **Interface:** `save(key, data)`, `load(key)`, `delete(key)`.
    *   **Dependencies:** `LoggingService`, potentially `ConfigurationService`.
    *   **Used By:** Agent Runtime/Logic.
*   **Agent Runtime:**
    *   **Responsibility:** Orchestrates the agent's execution loop or graph. Manages state, decides when to call models, tools, or MCP clients based on the agent definition and model output. Could potentially leverage concepts from LangGraph.
    *   **Interface:** Varies depending on implementation (e.g., `runAgent(initialInput)`).
    *   **Dependencies:** All other services.
    *   **Used By:** The main application entry point.
*   **Agent Definition:**
    *   **Responsibility:** User-provided code defining the specific goals, logic, prompts, and potentially custom tools/clients for a particular agent.
    *   **Interface:** Consumes the APIs provided by the framework services.
    *   **Dependencies:** Framework Services.
    *   **Used By:** Agent Runtime.
*   **Standard Libraries:**
    *   **Responsibility:** Pre-built collections of common Tools and MCP Clients provided by the framework.
    *   **Interface:** Exported definitions ready for registration with `ToolService` and `MCPClientService`.

## 5. Interactions and Data Flow

*   **Dependency Injection:** Services obtain references to other services via Effect's context system (`Effect.gen` or `Effect.flatMap` accessing context). Layers define the dependency graph.
*   **Configuration Flow:** `ConfigurationService` loads raw config. Services like `MCPClientService` request specific config sections, often validating them with Zod schemas defined within the client/tool definition.
*   **Execution Flow:** Typically starts with the Agent Runtime receiving input. It uses `PromptService` and `ModelProviderService` to interact with an LLM. Based on the LLM response, it might use `ToolService` to invoke a function or `MCPClientService` to interact with an external platform. Results are fed back to the LLM (via `ModelProviderService`) or used to update state (via `RepositoryService`). `LoggingService` captures events throughout.
*   **Error Propagation:** Errors are modeled as typed values within Effect's error channel (`Effect<A, E>`). Services return specific error types (e.g., `ToolNotFoundError`, `ClientInitializationError`). The Agent Runtime or higher-level logic handles these errors appropriately (retry, fallback, reporting).

## 6. Error Handling Strategy

*   Utilize Effect's typed error channel (`E` in `Effect<A, E>`).
*   Define specific, hierarchical error types for each service (e.g., `MCPClientError` base class with subtypes like `ClientNotFoundError`, `ClientConfigurationError`).
*   Use Effect operators (`catchAll`, `mapError`, `orDie`, `retry`) for error recovery and transformation.
*   Log errors with context using `LoggingService`.
*   Avoid throwing exceptions; return errors within the Effect error channel.

## 7. Configuration Management

*   Centralized management via `ConfigurationService`.
*   Support for multiple sources (e.g., `.env` files, JSON files, environment variables).
*   Schema definition and validation (using Zod) are encouraged, especially for complex configurations like those required by `MCPClientService`.
*   Clear structure for service-specific configuration (e.g., `mcpClients.<clientId>.*`, `tools.<toolId>.*`).
*   Secrets management should be handled carefully, ideally leveraging environment variables or dedicated secrets management solutions integrated via `ConfigurationService`.

## 8. Extensibility Points

*   **Tools:** Users can define custom `AnyTool` objects and register them with `ToolService`.
*   **MCP Clients:** Users can define custom `AnyMCPClient` objects (implementing the required interface including `initialize` and `configSchema`) and register them with `MCPClientService`.
*   **Prompts:** Add new prompt templates accessible via `PromptService`.
*   **Models:** Configure new LLM providers or models within `ModelProviderService` (may require code changes depending on abstraction level).
*   **Repositories:** Implement custom storage backends for `RepositoryService` (if the interface supports it).
*   **Agent Logic:** The core agent behavior is defined by the user.

## 9. Technology Stack

*   **Language:** TypeScript
*   **Core Framework:** Effect-TS
*   **Schema Validation:** Zod
*   **Runtime:** Node.js
*   **Potential Integrations:** Vercel AI SDK (for model interaction/streaming), LangGraph (for runtime orchestration patterns), specific SDKs for MCP clients (e.g., `@google-cloud/local-auth`, `@octokit/rest`, `@hubspot/api-client`).

## 10. Future Considerations

*   Advanced Caching strategies for initialized MCP clients.
*   Standardized patterns for handling complex authentication flows (OAuth2) within MCP clients.
*   Built-in support for common rate-limiting and retry strategies within MCP clients or a utility module.
*   More sophisticated state management options within `RepositoryService`.
*   Tool/Client discovery mechanisms beyond simple listing (e.g., semantic search).
