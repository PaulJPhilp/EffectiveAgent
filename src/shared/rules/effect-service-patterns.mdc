---
description: Patterns for implementing services using Effect
globs: **/*.ts
---
# Effect Service Patterns

## Service Interface Definition
- Define interface with readonly methods
- Use Effect return types for all operations
- Keep methods focused and single-purpose
```typescript
export interface ILoggingService {
    readonly getLogger: (name?: string) => Effect.Effect<Logger>
}
```

## Service Tag Creation
- Use Context.Tag for dependency injection
- Extend from Context.Tag with interface type
- Use same name as interface without 'I' prefix
```typescript
export class LoggingService extends Context.Tag("LoggingService")<
    ILoggingService,
    ILoggingService
>() {}
```

## Service Implementation
- Implement interface with concrete class
- Use private fields for internal state
- Keep implementation details hidden
```typescript
class LoggingServiceLive implements ILoggingService {
    private readonly loggers = new Map<string, Logger>()
    
    readonly getLogger = (name?: string): Effect.Effect<Logger> =>
        Effect.sync(() => {
            // Implementation
        })
}
```

## Service Layer Definition
- Create Layer for dependency injection
- Use Layer.succeed for simple services
- Use Layer.effect for services with dependencies
```typescript
export const LoggingServiceLiveLayer = Layer.succeed(
    LoggingService,
    new LoggingServiceLive()
)
```

## Service Dependencies
- Inject dependencies through constructor
- Use readonly for injected services
- Type dependencies with interfaces
```typescript
class ToolServiceLive implements IToolService {
    constructor(
        private readonly loggingService: ILoggingService,
        private readonly configurationService: ConfigurationService
    ) {}
}
```

## Service Method Implementation
- Use Effect.gen for complex operations
- Handle all error cases explicitly
- Log important state transitions
```typescript
registerTool(tool: AnyTool): Effect.Effect<void, ToolRegistrationError> {
    return Effect.gen(function* (_) {
        const log = yield* _(this.loggingService.getLogger("ToolService"))
        
        if (this.toolRegistry.has(tool.id)) {
            return yield* Effect.fail(new ToolRegistrationError(
                `Tool ${tool.id} already registered`
            ))
        }
        
        yield* Effect.sync(() => this.toolRegistry.set(tool.id, tool))
        yield* _(log.info("Tool registered", { toolId: tool.id }))
    })
}
```

## Service Composition
- Use pipe() for combining Effects
- Chain operations with yield*
- Maintain proper error typing
```typescript
return Effect.gen(function* (_) {
    const logger = yield* _(loggingService.getLogger())
    const config = yield* _(configService.getConfig())
    const result = yield* _(performOperation(config))
    yield* _(logger.info("Operation completed"))
    return result
})
```

## Service Testing
- Mock dependencies in tests
- Test success and error paths
- Verify service interactions
```typescript
const mockLogger = {
    info: () => Effect.succeed(undefined),
    error: () => Effect.succeed(undefined)
}
const mockLoggingService = {
    getLogger: () => Effect.succeed(mockLogger)
}
const service = new ServiceLive(mockLoggingService)
```

## Best Practices
1. Keep services focused on a single responsibility
2. Use Effect for all async/fallible operations
3. Properly type all Effects with success/error types
4. Log important operations and state changes
5. Use dependency injection for service composition
6. Handle all error cases explicitly
7. Test both success and error paths
8. Document public service interfaces
9. Use consistent naming conventions
10. Keep service methods small and focused

## Anti-patterns to Avoid
1. Don't mix Effect with Promises in service methods
2. Don't expose internal service state
3. Don't handle errors silently
4. Don't bypass the Effect type system
5. Don't use any or unknown types
6. Don't mix concerns across services 