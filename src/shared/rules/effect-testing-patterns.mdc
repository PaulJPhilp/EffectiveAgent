---
description: Patterns for testing Effect-based code using Vitest
globs: **/*.test.ts
---
# Effect Testing Patterns

## Test Structure
- Group tests by feature or service method
- Use descriptive test names that indicate behavior
- Follow the Arrange-Act-Assert pattern
```typescript
describe("DateTimeTool", () => {
    describe("PARSE operation", () => {
        it("should parse ISO date string", async () => {
            // Arrange
            const input = { operation: DateTimeOperation.PARSE, value: "2024-03-15T14:30:00[UTC]" }
            
            // Act
            const result = await Effect.runPromiseExit(dateTimeTool.execute(input, context))
            
            // Assert
            expect(Exit.isSuccess(result)).toBe(true)
            if (Exit.isSuccess(result)) {
                expect(typeof result.value.result).toBe("string")
            }
        })
    })
})
```

## Mock Service Setup
- Create mock services that implement the interface
- Use Effect.succeed for happy paths
- Use Effect.fail for error paths
```typescript
const mockLogger: Logger = {
    debug: () => Effect.succeed(undefined),
    info: () => Effect.succeed(undefined),
    warn: () => Effect.succeed(undefined),
    error: () => Effect.succeed(undefined),
    log: () => Effect.succeed(undefined)
}

const mockLoggingService: ILoggingService = {
    getLogger: () => Effect.succeed(mockLogger)
}
```

## Test Context Setup
- Create test context with all required dependencies
- Use beforeEach to reset state between tests
- Share common setup through test utilities
```typescript
describe("LoggingServiceLive", () => {
    let testContext: TestContext
    let loggingService: ILoggingService

    beforeEach(() => {
        testContext = createTestContext()
        const mockLoggingService = createMockLoggingService(testContext)
        const TestLoggerLayer = Layer.succeed(LoggingService, mockLoggingService)
        
        const program = Effect.gen(function* (_) {
            const service = yield* _(LoggingService)
            return service
        })
        loggingService = Effect.runSync(Effect.provide(program, TestLoggerLayer))
    })
})
```

## Testing Success Paths
- Verify successful operation results
- Check returned data structures
- Validate state changes
```typescript
it("should register tool successfully", async () => {
    const tool = createTestTool()
    const result = await Effect.runPromiseExit(service.registerTool(tool))
    
    expect(Exit.isSuccess(result)).toBe(true)
    expect(testContext.tools.has(tool.id)).toBe(true)
})
```

## Testing Error Paths
- Test all error conditions
- Verify correct error types
- Check error messages and metadata
```typescript
it("should fail with invalid format type", async () => {
    const input = {
        operation: DateTimeOperation.FORMAT,
        value: "2024-03-15T14:30:00[UTC]",
        params: { pattern: "invalid" }
    }

    const result = await Effect.runPromiseExit(dateTimeTool.execute(input, context))

    expect(Exit.isFailure(result)).toBe(true)
    if (Exit.isFailure(result)) {
        const failure = Option.getOrNull(Cause.failureOption(result.cause))
        expect(failure).toBeInstanceOf(FormatError)
    }
})
```

## Testing Effect Chains
- Test each step in complex Effect chains
- Verify intermediate state changes
- Check error propagation
```typescript
it("should handle multi-step operations", async () => {
    const result = await Effect.runPromiseExit(
        Effect.gen(function* (_) {
            const logger = yield* _(service.getLogger("test"))
            yield* _(logger.info("Step 1"))
            const data = yield* _(service.processData())
            yield* _(logger.info("Step 2"))
            return data
        })
    )
    
    expect(Exit.isSuccess(result)).toBe(true)
    expect(testContext.logs).toHaveLength(2)
})
```

## Testing Service Interactions
- Verify service method calls
- Check interaction order
- Validate passed parameters
```typescript
it("should log tool registration", async () => {
    const tool = createTestTool()
    await Effect.runPromiseExit(service.registerTool(tool))
    
    expect(testContext.logs).toContainEqual({
        level: LogLevel.Info,
        message: "Tool registered",
        annotations: { toolId: tool.id }
    })
})
```

## Testing Layer Composition
- Test services with their dependencies
- Verify layer initialization
- Check dependency injection
```typescript
it("should initialize with dependencies", async () => {
    const program = Effect.gen(function* (_) {
        const service = yield* _(ServiceTag)
        const result = yield* _(service.operation())
        return result
    })

    const result = await Effect.runPromiseExit(
        Effect.provide(program, ServiceLiveLayer)
    )
    
    expect(Exit.isSuccess(result)).toBe(true)
})
```

## Best Practices
1. Test both success and error paths
2. Use descriptive test names
3. Keep tests focused and isolated
4. Mock external dependencies
5. Reset state between tests
6. Test error propagation
7. Verify service interactions
8. Test complex Effect chains
9. Use proper type assertions
10. Document test scenarios

## Anti-patterns to Avoid
1. Don't test implementation details
2. Don't use real services in unit tests
3. Don't skip error cases
4. Don't mix async/sync test styles
5. Don't leave state between tests
6. Don't use real external services 